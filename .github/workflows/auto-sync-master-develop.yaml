# .github/workflows/sync-master-to-develop.yml
name: Auto-sync Master to Develop

on:
  push:
    branches: [master, main]  # Trigger on pushes to master/main branch
  workflow_dispatch:  # Allow manual triggering

env:
  INTERMEDIATE_BRANCH_PREFIX: "auto-sync/master-to-develop"
  TARGET_BRANCH: "develop"
  SOURCE_BRANCH: "master"  # Change to 'main' if using main branch
  PR_BYPASS: "true"  # Set to "true" to enable auto-merge bypass, "false" to wait for manual approval

jobs:
  sync-branches:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for proper branch operations
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Cleanup existing auto-sync branches
        id: cleanup-existing
        run: |
          echo "üßπ Checking for existing auto-sync branches..."
          
          # Fetch all remote branches
          git fetch --all
          
          # Find all auto-sync branches (both local and remote)
          EXISTING_BRANCHES=$(git branch -r | grep "origin/${INTERMEDIATE_BRANCH_PREFIX}" | sed 's/origin\///' | tr -d ' ' || echo "")
          
          if [[ -n "$EXISTING_BRANCHES" ]]; then
            echo "Found existing auto-sync branches:"
            echo "$EXISTING_BRANCHES"
            
            # Delete each existing auto-sync branch
            for branch in $EXISTING_BRANCHES; do
              if [[ "$branch" =~ ^${INTERMEDIATE_BRANCH_PREFIX} ]]; then
                echo "üóëÔ∏è Deleting existing branch: $branch"
                git push origin --delete "$branch" 2>/dev/null || echo "Branch $branch may have been already deleted"
                
                # Also delete local branch if it exists
                git branch -D "$branch" 2>/dev/null || echo "Local branch $branch not found"
              fi
            done
            
            echo "cleanup_performed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Cleanup of existing branches completed"
          else
            echo "No existing auto-sync branches found"
            echo "cleanup_performed=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate unique branch name
        id: branch-name
        run: |
          TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
          COMMIT_SHA=$(git rev-parse --short HEAD)
          BRANCH_NAME="${INTERMEDIATE_BRANCH_PREFIX}-${TIMESTAMP}-${COMMIT_SHA}"
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "Generated branch name: ${BRANCH_NAME}"

      - name: Create and push intermediate branch
        id: create-branch
        run: |
          BRANCH_NAME="${{ steps.branch-name.outputs.branch_name }}"
          
          # Ensure we're on the source branch and it's up to date
          git checkout ${{ env.SOURCE_BRANCH }}
          git pull origin ${{ env.SOURCE_BRANCH }}
          
          # Create intermediate branch from current master/main
          git checkout -b "${BRANCH_NAME}"
          git push origin "${BRANCH_NAME}"
          
          echo "branch_created=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Intermediate branch ${BRANCH_NAME} created and pushed"

      - name: Check for conflicts with develop
        id: conflict-check
        run: |
          BRANCH_NAME="${{ steps.branch-name.outputs.branch_name }}"
          
          # Fetch latest develop branch
          git fetch origin ${{ env.TARGET_BRANCH }}
          
          # Reset to clean state
          git reset --hard HEAD
          
          # Create a temporary test branch for conflict detection
          TEMP_TEST_BRANCH="temp-conflict-test-$(date +%s)"
          git checkout -b "${TEMP_TEST_BRANCH}"
          
          # Attempt to merge develop to detect conflicts
          echo "Testing merge from ${{ env.TARGET_BRANCH }} into ${TEMP_TEST_BRANCH}..."
          
          if git merge origin/${{ env.TARGET_BRANCH }} --no-commit --no-ff 2>/dev/null; then
            # Check if merge was successful (no conflicts)
            if git diff --cached --quiet && git diff --quiet; then
              echo "has_conflicts=false" >> $GITHUB_OUTPUT
              echo "‚úÖ No conflicts detected - branches can be merged cleanly"
              # Reset the merge since it was just a test
              git reset --hard HEAD
            else
              # There are changes staged/unstaged, meaning merge happened
              echo "has_conflicts=false" >> $GITHUB_OUTPUT
              echo "‚úÖ No conflicts detected - merge completed successfully"
              # Reset the merge since it was just a test
              git reset --hard HEAD
            fi
          else
            # Merge failed due to conflicts
            echo "has_conflicts=true" >> $GITHUB_OUTPUT
            echo "‚ùå Conflicts detected during merge!"
            # Reset to clean state
            git reset --hard HEAD
          fi
          
          # Switch back to original branch and cleanup
          git checkout "${BRANCH_NAME}"
          git branch -D "${TEMP_TEST_BRANCH}" 2>/dev/null || echo "Temp branch cleanup completed"
          
          echo "Conflict check completed. Has conflicts: $(cat $GITHUB_OUTPUT | grep has_conflicts | cut -d= -f2)"

      - name: Create Pull Request
        if: steps.conflict-check.outputs.has_conflicts == 'false'
        id: create-pr
        uses: actions/github-script@v7
        with:
          script: |
            const branchName = '${{ steps.branch-name.outputs.branch_name }}';
            const commitSha = context.sha.substring(0, 7);
            
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ü§ñ Auto-sync: ${context.payload.head_commit.message.split('\n')[0]}`,
              head: branchName,
              base: '${{ env.TARGET_BRANCH }}',
              body: `## üîÑ Automatic Sync from Master to Develop
              
              **Source Commit:** \`${commitSha}\`
              **Commit Message:** ${context.payload.head_commit.message}
              **Author:** @${context.payload.head_commit.author.username}
              
              ### Changes
              This PR automatically syncs changes from \`${{ env.SOURCE_BRANCH }}\` to \`${{ env.TARGET_BRANCH }}\`.
              
              **‚ö° Auto-generated by GitHub Actions**
              
              ---
              
              **üìã Merge Checklist:**
              - [ ] All CI checks pass
              - [ ] Code review completed (if required)
              - [ ] Ready to merge
              
              > This PR will be automatically merged if all checks pass and no conflicts are detected.`,
              draft: false
            });
            
            console.log(`Created PR #${pr.number}: ${pr.html_url}`);
            core.setOutput('pr_number', pr.number);
            core.setOutput('pr_url', pr.html_url);
            return pr.number;

      - name: Handle PR auto-merge or notification
        id: handle-pr
        if: steps.conflict-check.outputs.has_conflicts == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.create-pr.outputs.result }};
            const bypassEnabled = '${{ env.PR_BYPASS }}' === 'true';
            
            console.log(`üîß PR Bypass mode: ${bypassEnabled ? 'ENABLED' : 'DISABLED'}`);
            console.log(`üìã Processing PR #${prNumber}...`);
            
            if (!bypassEnabled) {
              console.log(`‚è∏Ô∏è Auto-merge disabled. PR #${prNumber} will wait for manual review and approval.`);
              core.setOutput('merge_status', 'manual_approval_required');
              core.setOutput('pr_action', 'waiting_for_approval');
              return;
            }
            
            // Bypass enabled - attempt immediate merge
            console.log(`üöÄ Attempting immediate auto-merge for PR #${prNumber}...`);
            
            try {
              // Get PR details first
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              if (pr.merged) {
                console.log(`‚úÖ PR #${prNumber} is already merged!`);
                core.setOutput('merge_status', 'already_merged');
                return;
              }
              
              // Check basic mergeable status
              if (pr.mergeable === false) {
                console.log(`‚ùå PR #${prNumber} has merge conflicts and cannot be auto-merged!`);
                core.setOutput('merge_status', 'conflicts');
                return;
              }
              
              // Attempt immediate merge with bypass
              console.log(`üîÑ Executing immediate merge for PR #${prNumber}...`);
              
              const mergeResult = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                commit_title: `ü§ñ Auto-sync: ${pr.title}`,
                commit_message: `Automatically synced from ${context.ref.replace('refs/heads/', '')} to ${{ env.TARGET_BRANCH }}

üîÑ **Auto-Sync Details:**
- Source: ${context.ref.replace('refs/heads/', '')}
- Target: ${{ env.TARGET_BRANCH }}
- Triggered by: ${context.actor}
- Commit: ${context.sha.substring(0, 7)}
- PR: ${pr.html_url}

ü§ñ This merge was performed automatically by GitHub Actions with bypass enabled`,
                merge_method: 'merge'
              });
              
              if (mergeResult.data.merged) {
                console.log(`‚úÖ Successfully auto-merged PR #${prNumber} immediately!`);
                console.log(`üîó Merge commit: ${mergeResult.data.sha}`);
                core.setOutput('merge_status', 'merged_immediately');
                core.setOutput('merge_sha', mergeResult.data.sha);
                core.setOutput('pr_action', 'auto_merged');
              } else {
                console.log(`‚ö†Ô∏è Merge API succeeded but status unclear`);
                core.setOutput('merge_status', 'uncertain');
                core.setOutput('pr_action', 'uncertain');
              }
              
            } catch (error) {
              console.log(`‚ùå Auto-merge failed: ${error.message}`);
              
              if (error.message.includes('required status check') || 
                  error.message.includes('branch protection') ||
                  error.message.includes('required review')) {
                console.log(`üõ°Ô∏è Branch protection rules prevent immediate auto-merge.`);
                console.log(`‚è≥ Will monitor PR and merge when requirements are met...`);
                
                // Fall back to monitoring mode
                core.setOutput('merge_status', 'monitoring_required');
                core.setOutput('pr_action', 'monitoring');
                
                // Start monitoring loop
                const maxAttempts = 20; // Reduced from 30 to 10 minutes max
                let attempts = 0;
                
                while (attempts < maxAttempts) {
                  attempts++;
                  await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds
                  
                  try {
                    // Re-check PR status
                    const { data: updatedPr } = await github.rest.pulls.get({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber
                    });
                    
                    if (updatedPr.merged) {
                      console.log(`‚úÖ PR #${prNumber} was merged! (attempt ${attempts})`);
                      core.setOutput('merge_status', 'merged_after_wait');
                      core.setOutput('pr_action', 'merged_after_checks');
                      return;
                    }
                    
                    if (updatedPr.mergeable === false) {
                      console.log(`‚ùå PR #${prNumber} developed conflicts during wait`);
                      core.setOutput('merge_status', 'conflicts_during_wait');
                      return;
                    }
                    
                    // Check if checks are now passing
                    const { data: checkRuns } = await github.rest.checks.listForRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: updatedPr.head.sha
                    });
                    
                    const { data: statusChecks } = await github.rest.repos.listCommitStatusesForRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: updatedPr.head.sha
                    });
                    
                    const allChecksPassed = checkRuns.check_runs.every(check => 
                      check.conclusion === 'success' || 
                      check.conclusion === 'neutral' || 
                      check.conclusion === 'skipped'
                    ) && statusChecks.every(status => 
                      status.state === 'success'
                    );
                    
                    if (allChecksPassed && updatedPr.mergeable) {
                      console.log(`üéØ All checks passed! Attempting merge... (attempt ${attempts})`);
                      
                      try {
                        const retryMergeResult = await github.rest.pulls.merge({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          pull_number: prNumber,
                          commit_title: `ü§ñ Auto-sync: ${updatedPr.title}`,
                          commit_message: `Auto-synced after checks passed (${attempts} attempts)`,
                          merge_method: 'merge'
                        });
                        
                        if (retryMergeResult.data.merged) {
                          console.log(`‚úÖ Successfully merged after ${attempts} attempts!`);
                          core.setOutput('merge_status', 'merged_after_checks');
                          core.setOutput('merge_sha', retryMergeResult.data.sha);
                          return;
                        }
                      } catch (retryError) {
                        console.log(`‚ö†Ô∏è Retry merge failed: ${retryError.message}`);
                      }
                    } else {
                      console.log(`‚è≥ Waiting for checks... (${attempts}/${maxAttempts})`);
                    }
                    
                  } catch (monitorError) {
                    console.log(`‚ö†Ô∏è Monitoring error: ${monitorError.message}`);
                  }
                }
                
                console.log(`‚è∞ Timeout reached after ${maxAttempts} attempts (10 minutes)`);
                core.setOutput('merge_status', 'timeout');
                core.setOutput('pr_action', 'timeout_waiting');
                
              } else {
                console.log(`üí• Unexpected error during auto-merge: ${error.message}`);
                core.setOutput('merge_status', 'failed');
                core.setOutput('pr_action', 'failed');
              }
            }

      - name: Send conflict notification
        if: steps.conflict-check.outputs.has_conflicts == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const commitSha = context.sha.substring(0, 7);
            const commitMessage = context.payload.head_commit.message.split('\n')[0];
            const commitAuthor = context.payload.head_commit.author.username;
            
            // Create an issue for conflict notification
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® Merge Conflict: Unable to sync master to develop`,
              body: `## ‚ö†Ô∏è Automatic Sync Failed - Merge Conflicts Detected
              
              **Failed Commit:** \`${commitSha}\`
              **Commit Message:** ${commitMessage}
              **Author:** @${commitAuthor}
              **Date:** ${new Date().toISOString()}
              
              ### üîç Issue Details
              The automatic sync from \`${{ env.SOURCE_BRANCH }}\` to \`${{ env.TARGET_BRANCH }}\` failed due to merge conflicts.
              
              ### üõ†Ô∏è Required Actions
              1. **Manual Review Required:** A developer needs to manually resolve the conflicts
              2. **Create Manual PR:** Create a pull request from \`${{ env.SOURCE_BRANCH }}\` to \`${{ env.TARGET_BRANCH }}\`
              3. **Resolve Conflicts:** Use your preferred merge tool to resolve conflicts
              4. **Test & Merge:** Ensure all tests pass before merging
              
              ### üìã Conflict Resolution Steps
              \`\`\`bash
              # 1. Create a new branch for conflict resolution
              git checkout ${{ env.TARGET_BRANCH }}
              git pull origin ${{ env.TARGET_BRANCH }}
              git checkout -b fix/sync-conflicts-${commitSha}
              
              # 2. Merge master and resolve conflicts
              git merge origin/${{ env.SOURCE_BRANCH }}
              # Resolve conflicts in your editor
              
              # 3. Commit and push
              git add .
              git commit -m "Resolve merge conflicts for sync from master"
              git push origin fix/sync-conflicts-${commitSha}
              
              # 4. Create PR through GitHub UI or CLI
              \`\`\`
              
              **ü§ñ This issue was automatically created by GitHub Actions**
              
              ---
              **Assignees:** Please assign this to the relevant team members
              **Labels:** \`conflict\`, \`auto-sync\`, \`needs-manual-resolution\``,
              labels: ['conflict', 'auto-sync', 'needs-manual-resolution', 'bug']
            });
            
            console.log(`Created conflict notification issue: ${issue.html_url}`);

      - name: Final cleanup - Ensure all auto-sync branches are removed
        if: always()
        run: |
          echo "üßπ Performing final cleanup of auto-sync branches..."
          
          # Get the current intermediate branch name
          CURRENT_BRANCH="${{ steps.branch-name.outputs.branch_name }}"
          
          # Fetch latest remote state
          git fetch --all --prune
          
          # Find and delete ALL auto-sync branches (including current one)
          REMAINING_BRANCHES=$(git branch -r | grep "origin/${INTERMEDIATE_BRANCH_PREFIX}" | sed 's/origin\///' | tr -d ' ' || echo "")
          
          if [[ -n "$REMAINING_BRANCHES" ]]; then
            echo "üóëÔ∏è Cleaning up remaining auto-sync branches:"
            for branch in $REMAINING_BRANCHES; do
              if [[ "$branch" =~ ^${INTERMEDIATE_BRANCH_PREFIX} ]]; then
                echo "Deleting branch: $branch"
                git push origin --delete "$branch" 2>/dev/null || echo "Branch $branch already deleted"
                
                # Clean up local branch if it exists
                git branch -D "$branch" 2>/dev/null || echo "Local branch $branch not found"
              fi
            done
            echo "‚úÖ Final cleanup completed"
          else
            echo "‚úÖ No auto-sync branches found - cleanup already complete"
          fi
          
          # Extra safety: Try to delete the current branch one more time
          if [[ -n "$CURRENT_BRANCH" ]]; then
            echo "üîÑ Final attempt to delete current branch: $CURRENT_BRANCH"
            git push origin --delete "$CURRENT_BRANCH" 2>/dev/null || echo "Current branch already cleaned up"
          fi

      - name: Slack Notification - Workflow Status
        if: always()
        run: |
          ACTIONS_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          ACTIONS_ACTOR=${{ github.event.sender.login }}
          BRANCH_NAME=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}
          REPO_NAME=${{ github.repository }}
          RELEASE_SLACK_URL=${{ secrets.RELEASE_SLACK_URL }}
          COMMIT_SHA=$(git rev-parse --short HEAD)
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          BYPASS_MODE="${{ env.PR_BYPASS }}"
          
          # Only send notification if we're on master/main branch
          if [ "$GITHUB_REF" == "refs/heads/master" ] || [ "$GITHUB_REF" == "refs/heads/main" ]; then
            if [[ "${{ steps.conflict-check.outputs.has_conflicts }}" == "true" ]]; then
              echo "Sending conflict notification to Slack..."
              curl -X POST -H 'Content-type: application/json' \
                --data '{
                  "attachments": [
                    {
                      "color": "#FF8C00",
                      "text": ":warning: GitHub Actions Auto-Sync: master ‚Üí develop **CONFLICT DETECTED** :warning:\n\n*Job:* Auto-sync Master to Develop\n*Triggered by:* '"${ACTIONS_ACTOR}"'\n*Repository:* '"${REPO_NAME}"'\n*Source Branch:* '"${BRANCH_NAME}"'\n*Target Branch:* develop\n*Commit:* `'"${COMMIT_SHA}"'`\n*Message:* '"${COMMIT_MSG}"'\n\n:exclamation: **Manual intervention required** - Merge conflicts detected!\n\n:point_right: Resolve conflicts manually and create PR\n:gear: Workflow Details: <'"${ACTIONS_URL}"'|Click to View>"
                    }
                  ]
                }' \
                ${RELEASE_SLACK_URL}
                
            elif [[ "${{ steps.create-pr.outputs.pr_number }}" != "" ]]; then
              PR_URL="${{ steps.create-pr.outputs.pr_url }}"
              PR_NUMBER="${{ steps.create-pr.outputs.pr_number }}"
              MERGE_STATUS="${{ steps.handle-pr.outputs.merge_status }}"
              PR_ACTION="${{ steps.handle-pr.outputs.pr_action }}"
              
              # Determine message based on merge status and bypass mode
              if [[ "$BYPASS_MODE" == "false" ]]; then
                # Bypass disabled - manual approval required
                echo "Sending manual approval notification to Slack..."
                curl -X POST -H 'Content-type: application/json' \
                  --data '{
                    "attachments": [
                      {
                        "color": "#FFA500",
                        "text": ":hourglass_flowing_sand: GitHub Actions Auto-Sync: master ‚Üí develop **WAITING FOR APPROVAL** :hourglass_flowing_sand:\n\n*Job:* Auto-sync Master to Develop\n*Triggered by:* '"${ACTIONS_ACTOR}"'\n*Repository:* '"${REPO_NAME}"'\n*Source Branch:* '"${BRANCH_NAME}"'\n*Target Branch:* develop\n*Commit:* `'"${COMMIT_SHA}"'`\n*Message:* '"${COMMIT_MSG}"'\n*Pull Request:* #'"${PR_NUMBER}"'\n*Bypass Mode:* DISABLED :lock:\n\n:point_right: **Manual review and approval required!**\n\n:point_right: **Review & Approve PR:** <'"${PR_URL}"'|Pull Request #'"${PR_NUMBER}"'>\n:gear: **Workflow Details:** <'"${ACTIONS_URL}"'|Click to View>"
                      }
                    ]
                  }' \
                  ${RELEASE_SLACK_URL}
                  
              elif [[ "$MERGE_STATUS" == "merged_immediately" ]] || [[ "$MERGE_STATUS" == "merged_after_wait" ]] || [[ "$MERGE_STATUS" == "merged_after_checks" ]]; then
                # Successfully merged with bypass
                echo "Sending successful merge notification to Slack..."
                curl -X POST -H 'Content-type: application/json' \
                  --data '{
                    "attachments": [
                      {
                        "color": "#36a64f",
                        "text": ":white_check_mark: GitHub Actions Auto-Sync: master ‚Üí develop **COMPLETED** :white_check_mark:\n\n*Job:* Auto-sync Master to Develop\n*Triggered by:* '"${ACTIONS_ACTOR}"'\n*Repository:* '"${REPO_NAME}"'\n*Source Branch:* '"${BRANCH_NAME}"'\n*Target Branch:* develop\n*Commit:* `'"${COMMIT_SHA}"'`\n*Message:* '"${COMMIT_MSG}"'\n*Pull Request:* #'"${PR_NUMBER}"' :merged:\n*Bypass Mode:* ENABLED :unlock:\n*Action:* '"${PR_ACTION}"'\n\n:rocket: **Sync completed successfully!** Changes are now in develop branch.\n\n:point_right: **View Merged PR:** <'"${PR_URL}"'|Pull Request #'"${PR_NUMBER}"'>\n:gear: **Workflow Details:** <'"${ACTIONS_URL}"'|Click to View>"
                      }
                    ]
                  }' \
                  ${RELEASE_SLACK_URL}
                  
              elif [[ "$MERGE_STATUS" == "timeout" ]]; then
                # Timeout while waiting for checks
                echo "Sending timeout notification to Slack..."
                curl -X POST -H 'Content-type: application/json' \
                  --data '{
                    "attachments": [
                      {
                        "color": "#FFA500",
                        "text": ":hourglass: GitHub Actions Auto-Sync: master ‚Üí develop **TIMEOUT** :hourglass:\n\n*Job:* Auto-sync Master to Develop\n*Triggered by:* '"${ACTIONS_ACTOR}"'\n*Repository:* '"${REPO_NAME}"'\n*Source Branch:* '"${BRANCH_NAME}"'\n*Target Branch:* develop\n*Commit:* `'"${COMMIT_SHA}"'`\n*Message:* '"${COMMIT_MSG}"'\n*Pull Request:* #'"${PR_NUMBER}"'\n*Bypass Mode:* ENABLED :unlock:\n\n:warning: **Timeout waiting for checks to complete!** PR may need manual intervention.\n\n:point_right: **Check PR Status:** <'"${PR_URL}"'|Pull Request #'"${PR_NUMBER}"'>\n:gear: **Workflow Details:** <'"${ACTIONS_URL}"'|Click to View>"
                      }
                    ]
                  }' \
                  ${RELEASE_SLACK_URL}
                  
              else
                # Default - PR created, bypass enabled but pending
                echo "Sending PR created with bypass notification to Slack..."
                curl -X POST -H 'Content-type: application/json' \
                  --data '{
                    "attachments": [
                      {
                        "color": "#36a64f",
                        "text": ":rocket: GitHub Actions Auto-Sync: master ‚Üí develop **PR CREATED** :rocket:\n\n*Job:* Auto-sync Master to Develop\n*Triggered by:* '"${ACTIONS_ACTOR}"'\n*Repository:* '"${REPO_NAME}"'\n*Source Branch:* '"${BRANCH_NAME}"'\n*Target Branch:* develop\n*Commit:* `'"${COMMIT_SHA}"'`\n*Message:* '"${COMMIT_MSG}"'\n*Pull Request:* #'"${PR_NUMBER}"'\n*Bypass Mode:* ENABLED :unlock:\n*Status:* '"${MERGE_STATUS}"'\n\n:white_check_mark: **Pull Request created successfully!** Auto-merge will attempt when checks pass.\n\n:point_right: **Monitor PR:** <'"${PR_URL}"'|Pull Request #'"${PR_NUMBER}"'>\n:gear: **Workflow Details:** <'"${ACTIONS_URL}"'|Click to View>"
                      }
                    ]
                  }' \
                  ${RELEASE_SLACK_URL}
              fi
              
            else
              echo "Sending general failure notification to Slack..."
              curl -X POST -H 'Content-type: application/json' \
                --data '{
                  "attachments": [
                    {
                      "color": "#FF0000",
                      "text": ":x: GitHub Actions Auto-Sync: master ‚Üí develop **FAILED** :x:\n\n*Job:* Auto-sync Master to Develop\n*Triggered by:* '"${ACTIONS_ACTOR}"'\n*Repository:* '"${REPO_NAME}"'\n*Source Branch:* '"${BRANCH_NAME}"'\n*Target Branch:* develop\n*Commit:* `'"${COMMIT_SHA}"'`\n*Message:* '"${COMMIT_MSG}"'\n\n:warning: **Sync workflow failed!** Please check the logs and resolve any issues.\n\n:gear: **Workflow Details:** <'"${ACTIONS_URL}"'|Click to View>"
                    }
                  ]
                }' \
                ${RELEASE_SLACK_URL}
            fi
          fi

      - name: Workflow Summary
        if: always()
        run: |
          echo "## üìä Sync Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Source Branch:** \`${{ env.SOURCE_BRANCH }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Target Branch:** \`${{ env.TARGET_BRANCH }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Intermediate Branch:** \`${{ steps.branch-name.outputs.branch_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Pre-cleanup Performed:** ${{ steps.cleanup-existing.outputs.cleanup_performed }}" >> $GITHUB_STEP_SUMMARY
          echo "**Conflicts Detected:** ${{ steps.conflict-check.outputs.has_conflicts }}" >> $GITHUB_STEP_SUMMARY
          echo "**PR Bypass Mode:** ${{ env.PR_BYPASS }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ steps.conflict-check.outputs.has_conflicts }}" == "true" ]]; then
            echo "‚ùå **Status:** Failed due to merge conflicts" >> $GITHUB_STEP_SUMMARY
            echo "üìã **Action Required:** Manual conflict resolution needed" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ steps.create-pr.outputs.pr_number }}" != "" ]]; then
            echo "‚úÖ **Status:** PR created successfully" >> $GITHUB_STEP_SUMMARY
            echo "üîó **PR Link:** ${{ steps.create-pr.outputs.pr_url }}" >> $GITHUB_STEP_SUMMARY
            echo "üîÑ **Merge Status:** ${{ steps.handle-pr.outputs.merge_status }}" >> $GITHUB_STEP_SUMMARY
            echo "‚ö° **PR Action:** ${{ steps.handle-pr.outputs.pr_action }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è **Status:** Workflow completed with issues" >> $GITHUB_STEP_SUMMARY
          fi
